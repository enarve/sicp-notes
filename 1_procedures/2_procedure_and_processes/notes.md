## Procedures and the processes they generate

Visualizing the processes generated by various types of procedures. Procedure as a pattern for the _local evolution_ of a computational process. _Global_ behavior of a process.

### Linear recursion and iteration

`n! = n * (n-1) * ... * 3 * 2 * 1` — factorial.
`n! = n * (n-1)!`

Shapes of processes.

Expansion followed by contraction, chain of _deferred operations_. _Recursive process_ is characterized by chain of _deferred operations_. Interpreter keeps track of operations to be performed later on. In `n!` — linear growth, `n` operations to remember. _Linear recursive process_.

_Iterative process_. Keeping track of _state variables_. Fixed rule to describe how states must be updated step to step. in `n!` — `n` steps, _linear iterative process_.

Recursive procedure — procedure that refers to itself. Not the same as recursive process, which describes process evolution, not syntactical definition.

Special-purpose _looping constructs_. _Tail-recursive_ implementation of language: keeping iterative process in constant (number of state varibles) space (memory).

### Tree recursion

Fibonacci numbers, each number is sum of the preceding two:
`0, 1, 1, 2, 3, 5, 8, 13, 21, ...`

Recursive and iterative versions of fibonacci numbers computation. Tree-like structure of recursive, exponential growth of steps. Efficiency of iteration with three state varibales.

#### Example: counting change
Compute the number of ways to combine smaller denomination into one dollar summarized.

### Orders of growth

Difference in consuming computational resources among processes. Let `n` measure the size of the problem, and `R(n)` be amount of resources required.

$R(n)$ has order of growth $\Theta(f(n))$ $R(n)=\Theta(f(n))$ if there are positive constants $k_1$ and $k_2$ independent of $n$ such that $k_1f(n)\le R(n) \le k_2f(n)$ for any sufficiently large value of $n$.

Orders of growth provide crude description of bahavior of a process. $\Theta(n)$, $\Theta(\phi^n)$, etc.